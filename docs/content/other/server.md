---
date: 2016-10-23T13:21:19-04:00
title: Server
---

This module is responsible for managing life cycle of the embedded Undertow core 
http server. It starts the server and initializes all middleware plugins along 
with route handler providers. It stops the server and allow the resources to be 
released even someone click CTRL+C.

## Startup Hooks

During server startup, a list of startup hooks will be called to initialize the
context and environment for the server instance. For example, creating database 
connection pool etc.

All startup hooks must implement the following interface.

```
public interface StartupHookProvider {
    void onStartup();
}
```

Startup hooks are loaded from SPI (service provider interface) so you must
create a config file com.networknt.server.StartupHookProvider in src/main/resources/META-INF/services

Here is an example.

```
# This is the place to plugin your startup hooks to initialize env,
# set up db connection pools and allocate resources.

# config Json Path to use Jackson Parser
com.networknt.server.JsonPathStartupHookProvider
```


## Shutdown Hooks

During server shutdown, a list of shutdown hooks will be called to clean up and
release resources for the server instance. For example, close all the database
connections in the connection pool etc.

All shutdown hooks must implement the following interface.

```
public interface ShutdownHookProvider {
    void onShutdown();
}
```

Shutdown hooks are loaded from SPI (Service Provider Interface) so you must
create a config file com.networknt.server.ShutdownHookProvider in src/main/resources/META-INF/services


## Middleware

Middleware plugins are the key components in the framework as they perform 
the heavy lifting behind the scene. These components address the cross 
cutting concerns for all API implementations so that API developers can 
focus on their domain logic only. Each component will have a config file 
(same name but with .yml/.yaml/.json ext) to control if the component will 
be enabled and its behavior. The framework has provide a list of the 
middleware plugins and experienced developers can add other plugins into 
the request/response chain.

To add your own middleware plugins, update com.networknt.handler.MiddlewareHandler 
in your API project folder src/main/resources/META-INF/services

Here is the default middleware configuration generated by 
[swagger-codegen](https://github.com/networknt/swagger-codegen)

```
# This file is generated and should not be changed unless you want to plug in more handlers into the handler chain
# for cross cutting concerns. In most cases, you should replace some of the default handlers with your own implementation
# Please note: the sequence of these handlers are very important.

#Validator Validate request based on swagger specification (depending on Swagger and Body)
com.networknt.validator.ValidatorHandler
#Sanitizer Encode cross site scripting
com.networknt.sanitizer.SanitizerHandler
#SimpleAudit Log important info about the request into audit log
com.networknt.audit.AuditHandler
#Body Parse body based on content type in the header.
com.networknt.body.BodyHandler
#Security JWT token verification and scope verification (depending on SwaggerHandler)
com.networknt.security.JwtVerifyHandler
#Swagger Parsing swagger specification based on request uri and method.
com.networknt.swagger.SwaggerHandler
#Correlation Create correlationId if it doesn't exist in the request header and put it into the request header
com.networknt.correlation.CorrelationHandler
#Traceability Put traceabilityId into response header from request header if it exists
com.networknt.traceability.TraceabilityHandler
#Metrics In order to calculate response time accurately, this needs to be the second.
com.networknt.metrics.MetricsHandler
#Exception Global exception handler that needs to be called first.
com.networknt.exception.ExceptionHandler

```

## Route Provider

[swagger-codegen](https://github.com/networknt/swagger-codegen) generates 
all the handlers and corresponding test cases based on OpenAPI specification. 
It also generate PathHandlerProvider to group these handlers together. This 
class is loaded by the server via Java SPI. The config file
com.networknt.server.HandlerProvider can be found at src/main/resources/META-INF/services

Here is an example of the config.

```
io.swagger.handler.PathHandlerProvider

```

## Configuration

server.yml is the configuration file for the server module to control the 
server behavior. 

Here is an example of server.yml

```
# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true.
httpPort: 8080

# Enable HTTP should be false on official environment.
enableHttp: true

# Https port if enableHttps is true.
httpsPort: 8443

# Enable HTTPS should be true on official environment.
enableHttps: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: io.swagger.swagger-light-4j-1.0.0

# Flag to enable service registration. Only be true if running as standalone Java jar.
enableRegistry: false

```

## Config Server

As an option, the config files for the server instance can be retrieved from
[light-config-server](https://github.com/networknt/light-config-server) 
instance. This is only needed if you run your service as standalone Java jar
or standalone docker container. When Kubernetes is used, then the config files
will be mapped to Kubernetes ConfigMap and Secret. 

If you want the server to load configuration files from config server, the
following environment variable must be set in the java -jar as option or pass
to docker container as environment variables.

* light-env
* light-config-server-uri

Once the server starts, it will access the [light-config-server](https://github.com/networknt/light-config-server) 
instance to get a zip file that contains config files for this particular service for 
this environment and this framework version. The zip file will be deflated automatically
and put all file into /config folder which is specified by light-4j-config-dir
system properties.


## Service Registry

If enableRegistry is true in server.yml, then the server will register itself
to Consul or Zookeeper whichever is configured in service.yml. The self
registration is only needed if you are running the server along without
docker. When docker is used, you can use [Registrator](https://github.com/gliderlabs/registrator)
for service registration. 


## Gracefully Shutdown

As we are using service registry, discovery and client side load balance, our
client will maintain a list of live services per serviceId. If any service
is shutting down, it will take a short while to propagate to all clients. In
order to handle in-flight request from the clients that don't know the server
instance is down, the server has to send a shutdown signal to registry and keep
processing for at least 20 to 30 seconds and then shutdown. Within this period
of time, all client should have known the service instance is gone and won't
send any new request to to it.


## TLS Hostname Verification

For testing, we can disable the hostname verification on the client for the 
certificate; however, it is recommended that on production, hostname 
verification should be turned on to eliminate man-in-the-middle attacks. 

You have two options:

* Buy certificates from a CA like VeriSign.
* Setup a CA in your organization and use openssl to generate certificate.

For more information

http://stackoverflow.com/questions/29546834/trust-not-trusted-certificates-and-skip-hostname-verification/29547114#29547114
https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning

